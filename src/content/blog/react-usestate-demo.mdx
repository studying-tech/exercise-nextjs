---
title: "【React入門】useStateを完全理解！対話的なUIを作ろう"
date: "2025-08-24"
author: "Tech Blog編集部"
coverImage: "images/blog-image5.jpg"
tags: ["React", "useState", "初心者", "JavaScript"]
excerpt: "Reactの基本フック「useState」の使い方を、動くコード例で徹底解説！普通の変数との違いから、インタラクティブなコンポーネントの作り方まで、初心者にも分かりやすく紹介します。"
published: true
---

# 【React 入門】useState を完全理解！対話的な UI を作ろう 🚀

React でユーザーの操作によって見た目が変わる「動的なコンポーネント」を作るとき、絶対に欠かせないのが **`useState`** フックです。この記事では、`useState` がなぜ必要なのか、そしてどうやって使うのかを、具体的なコードを交えながら見ていきましょう！

まずは実際に動くカウンターを触ってみてください：

<SimpleCounter />

## useState って何？ 🤔

`useState` は、一言でいうと **「コンポーネントに"記憶力"を与える魔法」** です。

通常の JavaScript 変数では、値が変わっても React はそれを検知できず、画面は更新されません。しかし `useState` を使えば、React に「この値が変わったから、画面を再描画してね！」と伝えることができます。

これにより、ユーザーのアクションに応じて表示がリアルタイムに変わる、インタラクティブな UI が実現できるのです。

## useState の基本的な使い方

### 1. 状態の宣言

まず、コンポーネント内で `useState` を呼び出して、状態を宣言します。

```javascript
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // この宣言で：
  // count は現在の値
  // setCount は値を更新する関数
  // useState(0) で初期値を 0 に設定
}
```

**重要なポイント：**

- `useState` は配列を返し、**分割代入**で 2 つの値を受け取ります
- 1 つ目は**現在の状態値**、2 つ目は**状態を更新する関数**
- 更新関数の名前は慣例的に `set + 状態名` にします

### 2. 状態の更新

状態を更新するには、`useState` から返された関数（上の例では `setCount`）を使います。

```javascript
function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1); // countを1増やす
  };

  const decrement = () => {
    setCount(count - 1); // countを1減らす
  };

  const reset = () => {
    setCount(0); // countを0にリセット
  };

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>リセット</button>
    </div>
  );
}
```

### 3. より実用的な例

文字列の状態管理も同じように行えます：

```javascript
function GreetingForm() {
  const [name, setName] = useState("");

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  return (
    <div>
      <input
        type="text"
        placeholder="お名前を入力してください"
        value={name}
        onChange={handleNameChange}
      />
      <p>こんにちは、{name || "名無し"}さん！</p>
    </div>
  );
}
```

## なぜ普通の変数ではダメなの？ 🤷‍♀️

初心者の方によくある疑問：「なんで普通の変数じゃダメなの？」

答えは**「React が変更を検知できないから」**です。

### ❌ 普通の変数の場合

```javascript
// これは動かない！
function BrokenCounter() {
  let count = 0; // 普通の変数

  const increment = () => {
    count = count + 1; // 値は変わる
    console.log(count); // コンソールには表示される
    // でも画面は更新されない！
  };

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

上記のコードでは、ボタンをクリックしても画面の数字は変わりません。なぜなら：

1. **再レンダリングが発生しない** - React は値の変更を検知できない
2. **関数が再実行されるたびに初期化** - `count` は毎回 0 に戻る
3. **状態の永続化ができない** - コンポーネントの状態を保持できない

### ✅ useState の場合

```javascript
// これは動く！
function WorkingCounter() {
  const [count, setCount] = useState(0); // useState を使う

  const increment = () => {
    setCount(count + 1); // Reactが変更を検知
    // 自動で画面が更新される！
  };

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

## useState の高度なテクニック

### 1. 関数型の更新

現在の値に基づいて更新する場合、より安全な書き方があります：

```javascript
function SafeCounter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    // 推奨：関数を渡す方法
    setCount((prevCount) => prevCount + 1);
  };

  const addFive = () => {
    // 複数回の更新も正確に動作
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
  };

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={addFive}>+5</button>
    </div>
  );
}
```

### 2. オブジェクトの状態管理

```javascript
function UserProfile() {
  const [user, setUser] = useState({
    name: "",
    email: "",
    age: 0,
  });

  const updateName = (newName) => {
    setUser((prevUser) => ({
      ...prevUser, // 既存のプロパティをコピー
      name: newName, // nameだけを更新
    }));
  };

  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => updateName(e.target.value)}
        placeholder="名前"
      />
      <p>名前: {user.name}</p>
    </div>
  );
}
```

## よくある落とし穴と解決方法

### 1. 状態の更新は非同期

```javascript
function AsyncUpdate() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    console.log(count); // まだ古い値！

    // 正しい方法：useEffectを使用
    // または関数型の更新を使用
  };
}
```

### 2. オブジェクトの更新は浅いコピーで

```javascript
// ❌ ダメな例：直接変更
const updateUser = () => {
  user.name = "新しい名前";
  setUser(user); // Reactは変更を検知しない
};

// ✅ 正しい例：新しいオブジェクトを作成
const updateUser = () => {
  setUser({
    ...user,
    name: "新しい名前",
  });
};
```

## まとめ

`useState` は React 開発において最も重要な概念の一つです：

- ✅ **状態管理** - コンポーネントに「記憶力」を与える
- ✅ **自動更新** - 値が変わると画面も自動で更新
- ✅ **シンプル** - `const [value, setValue] = useState(初期値)` だけ
- ✅ **強力** - あらゆるインタラクティブ UI の基盤
- ✅ **型安全** - TypeScript との相性も抜群

React の `useState` をマスターすれば、ユーザーの操作に応じて動的に変わる魅力的な UI を作ることができるようになります。

今回学んだ内容を活かして、ぜひ自分だけのインタラクティブなコンポーネントを作ってみてください！まずは簡単なカウンターから始めて、徐々に複雑な状態管理にチャレンジしていきましょう。 🎉
